// mytcpserver.cpp

#include "mytcpserver.h"
#include <iostream>

static inline QByteArray IntToArray(qint32 source);
static inline qint32 ArrayToInt(QByteArray source);

/**
 * @brief Server::Server constructs the server with port 38292 and initalizes the start_position of the players for the 3D_Game
 * Also the position and direction of the asteroids will be generated by the class Randomizer
 * @param user_data_1 start position of player 1
 * @param user_data_2 start position of player 2
 */
Server::Server(QObject* parent) : QObject(parent) {
    server = new QTcpServer(this);
    connect(server, SIGNAL(newConnection()), this, SLOT(newConnection()));
    bool connected = server->listen(QHostAddress::Any, 38292);
    if(connected){
        log(LoggingType::INFO, "Listening on Address: " + server->serverAddress().toString().toStdString());
        int port = server->serverPort();
        log(LoggingType::INFO, "Listening on Port: " + std::to_string(port));
    }else{
        log(LoggingType::ERROR, "Could not bind to port!");
        exit(0);
    }
    //default start position of the fighter player1
    user_data_1.position = {-650, 0, 0};
    user_data_1.xAxis[0] = -1;
    user_data_1.yAxis[1] = -1;
    user_data_1.zAxis[2] = 1;
    user_data_1.shot = Bullet_shot::not_shot;

    //default start position of the fighter player 2
    user_data_2.position = {0, 0, 0};
    user_data_2.xAxis[0] = 1;
    user_data_2.yAxis[1] = 1;
    user_data_2.zAxis[2] = 1;
    user_data_2.shot = Bullet_shot::not_shot;

    // generate asteroids with random position,size and direction:
    int amount = 10;
    for (int i{0}; i < amount; i++) {
        pos_astr[i] = asteroids::Randomizer::instance()->getRandomVertex(1000);
        dir_astr[i] = asteroids::Randomizer::instance()->getRandomVertex(1.0);
        size_astr[i] = asteroids::Randomizer::instance()->getRandomNumber(0, 100);
    }
}

/**
 * @brief Server::newConnection while clients are connecting accept and store sockets. When 2 players connected reject pending
 *  connections
 */
void Server::newConnection() {


    while (server->hasPendingConnections()) {
        QTcpSocket* socket = server->nextPendingConnection();
        log(LoggingType::INFO, "Client try to connect on Address: " + socket->peerAddress().toString().toStdString());

        //connect socket to slots so that when new data available readyRead is called
        connect(socket, SIGNAL(readyRead()), this, SLOT(readyRead()));

        //connect socket to slot so that disconnected is calles once the disconnected signal is transmitted
        connect(socket, SIGNAL(disconnected()), this, SLOT(disconnected()));

        // only accept two clients
        if (socket_1 == nullptr) {
            socket_1 = socket;
        } else if (socket_2 == nullptr) {
            socket_2 = socket;
        } else {
            socket->abort(); //abort if more than two clients try to connect
        }


        QByteArray* buffer = new QByteArray();
        qint32* s = new qint32(0);
        buffers.insert(socket, buffer);
        sizes.insert(socket, s);
        log(LoggingType::INFO, "Client connected successful on Address: " + socket->peerAddress().toString().toStdString());
    }
}

/**
 * @brief Server::disconnected once a client disconnects this function is called and the suiting socket is disconnected
 * @param socket the socket that disconneted
 */
void Server::disconnected() {
    // identify the client that disconnected
    QTcpSocket* socket = static_cast<QTcpSocket*>(sender());

    QByteArray* buffer = buffers.value(socket);
    qint32* s = sizes.value(socket);

    // reset the socket that disconected
    if (socket_1 == socket) {
        socket_1 = nullptr;
    } else if (socket_2 == socket) {
        socket_2 = nullptr;
    } else {

    }

    already_send_1 = false;
    already_send_2 = false;


    log(LoggingType::INFO, "Client disconnected on Address: " + socket->peerAddress().toString().toStdString());
    // Qt-way to destroy the socket
    socket->deleteLater();
    delete buffer;
    delete s;
    socket->flush();
}
/**
 * @brief Server::writeData writes the package that the Client requested depending on the param toSend
 * @return if data sent sucessfully
 */
bool Server::writeData(QByteArray const& data) {


    QTcpSocket* socket = static_cast<QTcpSocket*>(sender());
    QByteArray response;
    std::cerr << __PRETTY_FUNCTION__ << "\n";



    //to remove
    if(!user_data_1.m_first_connect || !user_data_2.m_first_connect)
    {
    std::cerr << __LINE__ << "\n";
        return false;
    }
    // if both players have connected to the server the game_start Package will be send to both clients
    else if(user_data_1.m_first_connect && user_data_2.m_first_connect && PacketType::game_start == toSend)
    {
        std::cerr << "Both players connected\n";
    }

    // sends the init Package if it has not been send already to the first client that has been connected
    else if (socket_1 != nullptr && socket_2 != nullptr && !already_send_1 && socket_1 == socket) {
    std::cerr << __LINE__ << "\n";
        toSend = PacketType::init_3D;
        already_send_1 = true;

    // sends the init Package if it has not been send already to the first client that has been connected
    } else if (socket_1 != nullptr && socket_2 != nullptr && !already_send_2 && socket_2 == socket) {
    std::cerr << __LINE__ << "\n";
        toSend = PacketType::init_3D;
        already_send_2 = true;
    }

    std::cerr << __LINE__ << "\n";
    //determine which packet has to be send

    // update package for 3D mode which stored fighter data
    if (toSend == PacketType::update_3D_C) {
        sendUpdate_3D_S(response, socket);
    //initalizing 3D fight
    } else if (toSend == PacketType::init_3D) {
        sendInit_3D(response, socket);
    // starts the game
    } else if(toSend == PacketType::game_start){
        bool bytes_written_1 = false;
        sendGame_Start(response, socket_1);
        if (socket_1->state() == QAbstractSocket::ConnectedState) {
            socket_1->write(response); // write the data itself
            bytes_written_1 = socket_1->waitForBytesWritten();
        } else {
            log(LoggingType::INFO, "Client not connected on Address: " + socket->peerAddress().toString().toStdString());
        }

        bool bytes_written_2 = false;
        QByteArray response_2;
        sendGame_Start(response_2, socket_2);
        if (socket_2->state() == QAbstractSocket::ConnectedState) {
            socket_2->write(response); // write the data itself
            bytes_written_2 = socket_2->waitForBytesWritten();
        } else {
            log(LoggingType::INFO, "Client not connected on Address: " + socket->peerAddress().toString().toStdString());
        }

        return bytes_written_1 && bytes_written_2;
    }

    // transmits the data to the socket that requested the package
    if (socket->state() == QAbstractSocket::ConnectedState) { // check if socket is still connected
        socket->write(response); // write the data itself
        return socket->waitForBytesWritten(); // wait until the data has been written to the buffer
    }
    // client should not be disconnected
    else {
        log(LoggingType::INFO, "Client not connected on Address: " + socket->peerAddress().toString().toStdString());
        return false;
    }
}
/**
 * @brief Server::sendUpdate_3D_S serverseitiges Packet welches regelmäig verschickt wird um die Position des Gegners
 * @param response array the data will be written to
 * @param socket client that will recive the package
 */
void Server::sendUpdate_3D_S(QByteArray& response, QTcpSocket* socket) {
    client_data client_data_temp;

    //player1 will recive the enemy package
    if (socket_1 == socket) {
        client_data_temp = user_data_2;

    //player2 recives data of player 1
    } else if (socket_2 == socket) {
        //client_data_temp = user_data_1;
        //std::cerr << "Socket send 1";
    } else {
        //std::cerr << "client socket not recognized\n";
        log(LoggingType::ERROR, "Client not recognized: " + socket->peerAddress().toString().toStdString());
    }
    // write the data to our array  size depends on values, Vector3f stores 3 floats with each having 4bytes
    response.append(PacketType::update_3D_S);
    response.append((char*) &client_data_temp.position, 3 * 4);
    response.append((char*) &client_data_temp.xAxis, 3 * 4);
    response.append((char*) &client_data_temp.yAxis, 3 * 4);
    response.append((char*) &client_data_temp.zAxis, 3 * 4);

    response.append(2, char{}); // anzahl zerstörter asteroidend short eine shor null
    // Asteroiden ids wenn nötig > 0

    response.append(client_data_temp.shot);
    response.append((char*) &client_data_temp.bullet_id, 4);
    response.append(Hit::hit);
    response.append(4, char{}); // zerstörte bullets
    // Bullet ids wenn nötig > 0
}

/**
 * @brief Server::recvUpdate_3D_C In 3D mode each clients sends his actual data: Poistion,alive,shot to the server
 * The server then sends a 3D_S package to each client so that he can update the position of his enemy in his game
 * @param data array the data will be written to
 * @param socket client that will recive the data
 */
void Server::recvUpdate_3D_C(char* data, QTcpSocket* socket) {
    client_data client_data_temp;

    //Position of the SpaceCraft
    client_data_temp.position[0] = getFloat(&data);
    client_data_temp.position[1] = getFloat(&data);
    client_data_temp.position[2] = getFloat(&data);

    //x-Axis of own SpaceCraft
    client_data_temp.xAxis[0] = getFloat(&data);
    client_data_temp.xAxis[1] = getFloat(&data);
    client_data_temp.xAxis[2] = getFloat(&data);

    //y-Axis of own SpaceCraft
    client_data_temp.yAxis[0] = getFloat(&data);
    client_data_temp.yAxis[1] = getFloat(&data);
    client_data_temp.yAxis[2] = getFloat(&data);

    //z-Axis of own SpaceCraft
    client_data_temp.zAxis[0] = getFloat(&data);
    client_data_temp.zAxis[1] = getFloat(&data);
    client_data_temp.zAxis[2] = getFloat(&data);

    // did a bullet get shot, and is the player still alive
    client_data_temp.shot = (Bullet_shot) getChar(&data);
    client_data_temp.bullet_id = getInt(&data);
    client_data_temp.living = (Living) getChar(&data);

    // client the data will be sent to
    if (socket_1 == socket) {
        user_data_1 = client_data_temp;
    } else if (socket_2 == socket) {
        user_data_2 = client_data_temp;
    } else {
        //std::cerr << "client socket not recognized\n";
        log(LoggingType::ERROR, "Client not recognized: " + socket->peerAddress().toString().toStdString());
    }
}

/**
 * @brief Server::recvReady_T signalizes if the client has been connected and is ready to start the game it stores the ID
 * of the player
 * @param data array the data will be written to
 * @param socket client where the data came from
 * @param length length of the player_id
 * @param id id of the player
 */
void Server::recvReady_T(char* data, QTcpSocket* socket) {
    int length = getInt(&data);
    char id[length + 1];
    for(int i = 0; i < length; i++)
    {
        id[i] = getChar(&data);
    }
    id[length] = '\0';

    std::string name = std::string(id);

    if (socket_1 == socket) {
        user_data_1.name = name;
        user_data_1.m_first_connect = true;
    } else if (socket_2 == socket) {
        user_data_2.name = name;
        user_data_2.m_first_connect = true;
    } else {
        //std::cerr << "client socket not recognized\n";
        log(LoggingType::ERROR, "Client not recognized: " + socket->peerAddress().toString().toStdString());
    }
}

/**
 * @brief Server::sendInit_3D sends the package to initalize asteroids and SpaceCraft positions to both clients
 * After every fight the position and asteroids are reset
 * @param response array where the data will be written to
 * @param socket client that recives the data
 */
void Server::sendInit_3D(QByteArray& response, QTcpSocket* socket) {

    // own data like Position,alive flag etc.
    client_data client_data_temp_own;
    //enemy data
    client_data client_data_temp_enemy;

    // depending on player set the data accordingly
    if (socket_1 == socket) {
        client_data_temp_own = user_data_1;
        client_data_temp_enemy = user_data_2;
    } else if (socket_2 == socket) {
        client_data_temp_own = user_data_2;
        client_data_temp_enemy = user_data_1;
    } else {
        //std::cerr << "client socket not recognized\n";
        log(LoggingType::ERROR, "Client not recognized: " + socket->peerAddress().toString().toStdString());
    }

    //write the packet
    response.append(PacketType::init_3D);

    //write own data
    response.append((char*) &client_data_temp_own.position, 12);
    response.append((char*) &client_data_temp_own.xAxis, 12);
    response.append((char*) &client_data_temp_own.yAxis, 12);
    response.append((char*) &client_data_temp_own.zAxis, 12);

    //write enemy data
    response.append((char*) &client_data_temp_enemy.position, 12);
    response.append((char*) &client_data_temp_enemy.xAxis, 12);
    response.append((char*) &client_data_temp_enemy.yAxis, 12);
    response.append((char*) &client_data_temp_enemy.zAxis, 12);

    // create random asteroids, amount is hard coded
    int amount = 10;
    response.append((char*) &amount, 4);

    // add asteroids position,size and direction to package
    for (int i = 0; i < amount; i++) {
        response.append((char*) &i, 4);

        asteroids::Vector3f tmp = pos_astr[i];
        response.append((char*) &tmp, 12);

        tmp = dir_astr[i];
        response.append((char*) &tmp, 12);

        float size = size_astr[i];
        response.append((char*) &size, 4);
    }
}

/**
 * @brief Server::sendGame_Start once the Server has recived the Ready_T package from both player this function is called which
 * tells the player his player id depending on the player_no flag
 * @param response array to manipulate the data
 * @param socket the reciver of the message
 */
void Server::sendGame_Start(QByteArray& response, QTcpSocket* socket) {
    //userdata
    client_data client_data_temp_own;
    client_data client_data_temp_enemy;
    if (socket_1 == socket) {
        client_data_temp_own = user_data_1;
        client_data_temp_enemy = user_data_2;
    } else if (socket_2 == socket) {
        client_data_temp_own = user_data_2;
        client_data_temp_enemy = user_data_1;
    } else {
        //std::cerr << "client socket not recognized\n";
        log(LoggingType::ERROR, "Client not recognized: " + socket->peerAddress().toString().toStdString());
    }
    //package type
    response.append(PacketType::game_start);

    //length of the id
    int length = client_data_temp_enemy.name.length();
    response.append((char*)&length, 4);

    //assign player_no to each player and send the package
    response.append(client_data_temp_enemy.name.c_str(), length);
    if (socket_1 == socket) {
        response.append(player_no::first);
        std::cerr << "socket_1 player_no::first\n";
    } else if (socket_2 == socket) {
        response.append(player_no::second);
        std::cerr << "socket_2 player_no::first\n";
    }

    //TODO send fist map config data
}


void Server::log(LoggingType type, std::string msg){
    time_t rawtime;
    struct tm * timeinfo;
    char buffer[80];

    time (&rawtime);
    timeinfo = localtime(&rawtime);

    strftime(buffer,sizeof(buffer),"%d-%m-%Y %H:%M:%S",timeinfo);
    std::string str(buffer);

    std::ofstream logfile;
    logfile.open ("log.txt");
    if(type == LoggingType::ERROR){
        std::cerr << "[" << str << " ERROR] " << msg << "\n";
        logfile << "[" << str << " ERROR] " << msg << "\n";
    }else if(type == LoggingType::INFO){
        std::cout << "[" << str << " INFO] " << msg << std::endl;
        logfile << "[" << str << " INFO] " << msg << std::endl;
    }
    logfile.close();
}

/**
 * @brief Server::readyRead recives the Packages sent from each client and interprets the package type. Handles what to do
 * after reciving a package
 */
void Server::readyRead() {

    //determine sender of packet
    QTcpSocket* socket = static_cast<QTcpSocket*>(sender());

    //read the data
    QByteArray* buffer = buffers.value(socket);
    qint32* s = sizes.value(socket);
    qint32 size = *s;
    while (socket->bytesAvailable() > 0) {
        buffer->append(socket->readAll());
        while ((size == 0 && buffer->size() >= 4) ||
               (size > 0 && buffer->size() >= size)) // While can process data, process it
        {
            if (size == 0 && buffer->size() >= 4) // if size of data has received completely, then
                                                  // store it on our global variable
            {
                size = ArrayToInt(buffer->mid(0, 4));
                *s = size;
                buffer->remove(0, 4);
            }
            // If data has received completely, then emit
            // our SIGNAL with the data
            if (size > 0 && buffer->size() >= size)

            {
                QByteArray answer = buffer->mid(0, size);
                buffer->remove(0, size);
                size = 0;
                *s = size;

                // Interprete the packet-type:
                char* data = (char*) answer.data();
                PacketType pt = (PacketType) getChar(&data);



                //depending on packetType call suiting function
                if (pt == PacketType::update_3D_C && already_send_1 && already_send_2) {
                    recvUpdate_3D_C(data, socket);
                    toSend = PacketType::update_3D_C;
                } else if (pt == PacketType::ready_T) {
                std::cerr << __LINE__ << "_ready_t"  << "\n";
                    recvReady_T(data, socket);
                    toSend = PacketType::game_start;
                }
                //write the data after maniuplating the array with the suiting function
                std::cerr << __LINE__ << "before wirteData"  << "\n";
                this->writeData(nullptr);
            }
        }
    }
}

// maniuplate the QByteArray for depending values of package we are reciving
float Server::getFloat(char** ptr) {
    float* jo = (float*) *ptr;
    float f = *jo;
    *ptr += 4;
    return f;
}

/**
 * @brief Server::getShort manipulates the pointer by incrementing and returning short value
 * @param ptr pointer that will be manipulated
 * @return short Value at position of pointer
 */
short Server::getShort(char** ptr) {
    short* jo = (short*) *ptr;
    short f = *jo;
    *ptr += 2;
    return f;
}

/**
 * @brief Server::getChar manipulates the pointer by incrementing and returning short value
 * @param ptr pointer that will be manipulated
 * @return char value at position
 */
char Server::getChar(char** ptr) {
    char f = **ptr;
    *ptr += 1;
    return f;
}

/**
 * @brief Server::getInt manipulates the pointer by incrementing and returning short value
 * @param ptr pointer that will be manipulated
 * @return int Value at position
 */
int Server::getInt(char** ptr) {
    int* jo = (int*) *ptr;
    int f = *jo;
    *ptr += 4;
    return f;
}

/**
 * @brief ArrayToInt serializes the array in qt-Way
 * @param source data to ber serialized
 */
qint32 ArrayToInt(QByteArray source) {
    qint32 temp;
    QDataStream data(&source, QIODevice::ReadWrite);
    data >> temp;
    return temp;
}

/**
 * @brief IntToArray deserializes source
 */
QByteArray IntToArray(qint32 source) // Use qint32 to ensure that the number have 4 bytes
{

    QByteArray temp;
    QDataStream data(&temp, QIODevice::ReadWrite);
    data << source;
    return temp;
}

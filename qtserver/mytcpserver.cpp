// mytcpserver.cpp

#include "mytcpserver.h"
#include <iostream>


static inline QByteArray IntToArray(qint32 source);
static inline qint32 ArrayToInt(QByteArray source);

/**
 * @brief Server::Server constructs the server with port 38292 and initalizes the start_position of the players for the 3D_Game
 * Also the position and direction of the asteroids will be generated by the class Randomizer
 * @param user_data_1 start position of player 1
 * @param user_data_2 start position of player 2
 */
Server::Server(QObject* parent) : QObject(parent), physics(user_data_1, user_data_2) {
    server = new QTcpServer(this);
    connect(server, SIGNAL(newConnection()), this, SLOT(newConnection()));
    bool connected = server->listen(QHostAddress::Any, 38292);
    if(connected){
        log(LoggingType::INFO, "Listening on Address: " + server->serverAddress().toString().toStdString());
        int port = server->serverPort();
        log(LoggingType::INFO, "Listening on Port: " + std::to_string(port));
    }else{
        log(LoggingType::ERROR, "Could not bind to port!");
        exit(0);
    }

    //default start position of the fighter player1
    user_data_1.position = {-200, 200, 0};
    user_data_1.xAxis[0] = -1;
    user_data_1.yAxis[1] = -1;
    user_data_1.zAxis[2] = 1;
    user_data_1.shot = Bullet_shot::not_shot;
    //default start position of the fighter player 2
    user_data_2.position = {100, -0, -0};
    user_data_2.xAxis[0] = 1;
    user_data_2.yAxis[1] = 1;
    user_data_2.zAxis[2] = 1;
    user_data_2.shot = Bullet_shot::not_shot;

    // generate asteroids with random position,size and direction:
    int amount = 10;
    for (int i{0}; i < amount; i++) {
        pos_astr[i] = asteroids::Randomizer::instance()->getRandomVertex(1000);
        float rand = asteroids::Randomizer::instance()->getRandomNumber(0, 0.1);
        dir_astr[i] = asteroids::Randomizer::instance()->getRandomVertex(1.0) * rand;
        size_astr[i] = asteroids::Randomizer::instance()->getRandomNumber(0, 100);

        physics.addAsteroid(asteroids::ServerAsteroid::Ptr(new asteroids::ServerAsteroid(pos_astr[i], dir_astr[i], 1, size_astr[i], i)));
    }
    pchanges_size1 = -1;
    pchanges_size2 = -1;
}

/**
 * @brief Server::newConnection while clients are connecting accept and store sockets. When 2 players connected reject pending
 *  connections
 */
void Server::newConnection() {


    while (server->hasPendingConnections()) {
        QTcpSocket* socket = server->nextPendingConnection();
        log(LoggingType::INFO, "Client try to connect on Address: " + socket->peerAddress().toString().toStdString());

        //connect socket to slots so that when new data available readyRead is called
        connect(socket, SIGNAL(readyRead()), this, SLOT(readyRead()));

        //connect socket to slot so that disconnected is calles once the disconnected signal is transmitted
        connect(socket, SIGNAL(disconnected()), this, SLOT(disconnected()));

        // only accept two clients
        if (socket_1 == nullptr) {
            socket_1 = socket;
        } else if (socket_2 == nullptr) {
            socket_2 = socket;
        } else {
            socket->abort(); //abort if more than two clients try to connect
        }


        QByteArray* buffer = new QByteArray();
        qint32* s = new qint32(0);
        buffers.insert(socket, buffer);
        sizes.insert(socket, s);
        log(LoggingType::INFO, "Client connected successful on Address: " + socket->peerAddress().toString().toStdString());
    }
}

/**
 * @brief Server::disconnected once a client disconnects this function is called and the suiting socket is disconnected
 * @param socket the socket that disconneted
 */
void Server::disconnected() {
    // identify the client that disconnected
    QTcpSocket* socket = static_cast<QTcpSocket*>(sender());

    QByteArray* buffer = buffers.value(socket);
    qint32* s = sizes.value(socket);

    // reset the socket that disconected
    if (socket_1 == socket) {
        socket_1 = nullptr;
    } else if (socket_2 == socket) {
        socket_2 = nullptr;
    } else {

    }

    already_send_1 = false;
    already_send_2 = false;


    log(LoggingType::INFO, "Client disconnected on Address: " + socket->peerAddress().toString().toStdString());
    // Qt-way to destroy the socket
    socket->deleteLater();
    delete buffer;
    delete s;
    socket->flush();
}
/**
 * @brief Server::writeData writes the package that the Client requested depending on the param toSend
 * @return if data sent sucessfully
 */
bool Server::writeData(QByteArray const& data) {
    //std::cerr << __LINE__ << ", " << __PRETTY_FUNCTION__ << " packet received sucevfully \n";
    QTcpSocket* socket = static_cast<QTcpSocket*>(sender());


    QByteArray response;

    //PacketType toSend = PacketType::update_3D_C;

    /*
    //to remove
    if (socket_1 != nullptr && socket_2 != nullptr && !already_send_1 && socket_1 == socket) {
        toSend = PacketType::init_3D;
        already_send_1 = true;
        physics.run();
    } else if (socket_1 != nullptr && socket_2 != nullptr && !already_send_2 && socket_2 == socket) {
        toSend = PacketType::init_3D;
        already_send_2 = true;

    if(PacketType::update_3D_C == toSend){
        //std::cerr << "\t" << __LINE__ << "\n";
    } else if( !user_data_1.m_first_connect || !user_data_2.m_first_connect)
    {
        //std::cerr << "\t" << __LINE__ << __FUNCTION__ << "\n";
        return false;
    }
	*/

    //std::cerr << "\t" << __LINE__ << __FUNCTION__ << "\n";
    //determine which packet has to be send

    // update package for 3D mode which stored fighter data
    if (toSend == PacketType::update_3D_C) {
        //std::cerr << "\t" << __LINE__ << __FUNCTION__ << "\n";
        sendUpdate_3D_S(response, socket);
    } /*else if(send_changes) {
        //std::cerr << "\t" << __LINE__ << "\n";
        toSend = PacketType::planet_changes2d;
        send_changes = false;
    }*/
    else if (toSend == PacketType::init_3D) {
        ////std::cerr << "\t" << __LINE__ << "\n";
        //sendInit_3D(response, socket);
        m_player1_end_3d_received = false;
        user_data_1.position = {-200, 200, 0};
        user_data_1.xAxis[0] = -1;
        user_data_1.yAxis[1] = -1;
        user_data_1.zAxis[2] = 1;
        user_data_1.shot = Bullet_shot::not_shot;
        user_data_2.position = {100, -0, -0};
        user_data_2.xAxis[0] = 1;
        user_data_2.yAxis[1] = 1;
        user_data_2.zAxis[2] = 1;
        user_data_2.shot = Bullet_shot::not_shot;
        //std::cerr << "\t" << __LINE__ << __FUNCTION__ << " init_3D \n";
        bool bytes_written_1 = false;
        sendInit_3D(response, socket_1);
        if ( socket_1->state() == QAbstractSocket::ConnectedState) {
        //std::cerr << "\t" << __LINE__ << __FUNCTION__ << "\n";
            socket_1->write(response); // write the data itself
            bytes_written_1 = socket_1->waitForBytesWritten();
        } else {
            log(LoggingType::INFO, "Client not connected on Address: " + socket->peerAddress().toString().toStdString());
        }

        bool bytes_written_2 = false;
        QByteArray response_2;
        sendInit_3D(response_2, socket_2);
        if ( socket_2->state() == QAbstractSocket::ConnectedState) {
        //std::cerr << "\t" << __LINE__ << __FUNCTION__ << "\n";
            socket_2->write(response_2); // write the data itself
            bytes_written_2 = socket_2->waitForBytesWritten();
        } else {
            log(LoggingType::INFO, "Client not connected on Address: " + socket->peerAddress().toString().toStdString());
        }

        //return bytes_written_1 && bytes_written_2;
        physics.run();
        //std::cerr << "\t" << __LINE__ << __FUNCTION__ << " written both init_3d_packets\n";
        return true;
    } else if(toSend == PacketType::game_start){
        //std::cerr << "\t" << __LINE__ << __FUNCTION__ << " game_start\n";
        bool bytes_written_1 = false;
        if ( socket_1 == socket && socket_1->state() == QAbstractSocket::ConnectedState) {
            sendGame_Start(response, socket_1);
            //std::cerr << "\t" << __LINE__ << __FUNCTION__ << " socket_1\n";
            socket_1->write(response); // write the data itself
            bytes_written_1 = socket_1->waitForBytesWritten();
        } else {
            log(LoggingType::INFO, "Client not connected on Address: " + socket->peerAddress().toString().toStdString());
        }

        bool bytes_written_2 = false;
        if ( socket_2 == socket && socket_2->state() == QAbstractSocket::ConnectedState) {
            QByteArray response_2;
            sendGame_Start(response_2, socket_2);
            //std::cerr << "\t" << __LINE__ << __FUNCTION__ << " socket_2\n";
            socket_2->write(response_2); // write the data itself
            bytes_written_2 = socket_2->waitForBytesWritten();
        } else {
            log(LoggingType::INFO, "Client not connected on Address: " + socket->peerAddress().toString().toStdString());
        }

        //return bytes_written_1 && bytes_written_2;
        //std::cerr << "\t" << __LINE__ << __FUNCTION__ << " written game_start_packet\n";
        return true;
    }

    if (socket->state() == QAbstractSocket::ConnectedState) {
        //std::cerr << "\t" << __LINE__ << __FUNCTION__ << " data written\n";
        socket->write(response); // write the data itself
        return socket->waitForBytesWritten(); // wait until the data has been written to the buffer
    }
    // client should not be disconnected
    else {
        log(LoggingType::INFO, "Client not connected on Address: " + socket->peerAddress().toString().toStdString());
        ////std::cerr << "\t" << socket->state() << ": connected State\n";
        return false;
    }
    //std::cerr << "\n";
}
/**
 * @brief Server::sendUpdate_3D_S serverseitiges Packet welches regelmÃ¤ig verschickt wird um die Position des Gegners
 * @param response array the data will be written to
 * @param socket client that will recive the package
 */
void Server::sendUpdate_3D_S(QByteArray& response, QTcpSocket* socket) {
    client_data client_data_temp;

    //player1 will recive the enemy package
    if (socket_1 == socket) {
        client_data_temp = user_data_2;
    } else if (socket_2 == socket) {
        client_data_temp = user_data_1;
    } else {
        ////std::cerr << "\t" << "client socket not recognized\n";
        log(LoggingType::ERROR, "Client not recognized: " + socket->peerAddress().toString().toStdString());
    }
    // write the data to our array  size depends on values, Vector3f stores 3 floats with each having 4bytes
    response.append(PacketType::update_3D_S);
    response.append((char*) &client_data_temp.position, 3 * 4);
    response.append((char*) &client_data_temp.xAxis, 3 * 4);
    response.append((char*) &client_data_temp.yAxis, 3 * 4);
    response.append((char*) &client_data_temp.zAxis, 3 * 4);


    std::vector<int> ids_astr;

    if(socket == socket_1){
        ids_astr = physics.getDelAstr1();
    }else{
        ids_astr = physics.getDelAstr2();
    }

    short length = ids_astr.size();
    response.append((char*)&length, 2); // anzahl zerstÃ¶rter asteroidend short eine shor null
    for(auto it : ids_astr){
        response.append((char*)&it, 4);
    }
    // client_data_temp.deleted_asteroids_id.clear();
    // Asteroiden ids wenn nÃ¶tig > 0

    response.append(client_data_temp.shot);
    response.append((char*) &client_data_temp.bullet_id, 4);

    //RIGHT?????????????????????????????????????????
    response.append(Hit::hit);

    //BULLETS
    std::vector<int> ids;

    if(socket == socket_1){
        ids = physics.getDelBullets1();
    }else{
        ids = physics.getDelBullets2();
    }

    int b_length = ids.size();
    response.append((char*)&b_length, 4); // anzahl zerstÃ¶rter Bullets short eine shor null

    for(auto it : ids){
        response.append((char*)&it, 4);
        log(LoggingType::DEBUG, "Bullet removed SEND TO CLIENT: " + std::to_string(it));
    }
    //client_data_temp.deleted_bullets_id.clear();
    // Bullet ids wenn nÃ¶tig > 0

    if(socket_1 == socket){
        int own = physics.getFirstHealth();
        response.append((char*)&own, 4);
        int enemy = physics.getSecondHealth();
        response.append((char*)&enemy, 4);
    }else{
        int own = physics.getSecondHealth();
        response.append((char*)&own, 4);
        int enemy = physics.getFirstHealth();
        response.append((char*)&enemy, 4);
    }

    //update bullets
    int changed_count = physics.m_first_bullets.size() + physics.m_second_bullets.size();
    response.append((char*)&changed_count, 4);
    for(auto it : physics.m_first_bullets){
        response.append((char*) &it->m_id, 4);
        response.append((char*) &it->m_pos, 3 * 4);
        response.append((char*) &it->m_dir, 3 * 4);
    }
    for(auto it : physics.m_second_bullets){
        response.append((char*) &it->m_id, 4);
        response.append((char*) &it->m_pos, 3 * 4);
        response.append((char*) &it->m_dir, 3 * 4);
    }
    //update astr
    int astr_count = physics.m_asteroids.size();
    response.append((char*)&astr_count, 4);
    for(auto it : physics.m_asteroids){
        response.append((char*) &it->m_id, 4);
        response.append((char*) &it->m_pos, 3 * 4);
        ////std::cerr << it->m_id <<"pos von astr : ||" << it->m_pos << "||";
    }
}

/**
 * @brief Server::recvUpdate_3D_C In 3D mode each clients sends his actual data: Poistion,alive,shot to the server
 * The server then sends a 3D_S package to each client so that he can update the position of his enemy in his game
 * @param data array the data will be written to
 * @param socket client that will recive the data
 */
void Server::recvUpdate_3D_C(char* data, QTcpSocket* socket) {
    //std::cerr << __LINE__ << ", " << __PRETTY_FUNCTION__ << "\n";
    client_data client_data_temp;

    //Position of the SpaceCraft
    client_data_temp.position[0] = getFloat(&data);
    client_data_temp.position[1] = getFloat(&data);
    client_data_temp.position[2] = getFloat(&data);

    //x-Axis of own SpaceCraft
    client_data_temp.xAxis[0] = getFloat(&data);
    client_data_temp.xAxis[1] = getFloat(&data);
    client_data_temp.xAxis[2] = getFloat(&data);

    //y-Axis of own SpaceCraft
    client_data_temp.yAxis[0] = getFloat(&data);
    client_data_temp.yAxis[1] = getFloat(&data);
    client_data_temp.yAxis[2] = getFloat(&data);

    //z-Axis of own SpaceCraft
    client_data_temp.zAxis[0] = getFloat(&data);
    client_data_temp.zAxis[1] = getFloat(&data);
    client_data_temp.zAxis[2] = getFloat(&data);

    // did a bullet get shot, and is the player still alive
    client_data_temp.shot = (Bullet_shot) getChar(&data);
    client_data_temp.bullet_id = getInt(&data);
    if(client_data_temp.shot == Bullet_shot::shot){
        asteroids::Vector3f shipPosition = client_data_temp.position + client_data_temp.zAxis * -45 + client_data_temp.xAxis * -175;
        physics.addBullet(asteroids::ServerBullet::Ptr(new asteroids::ServerBullet(shipPosition, client_data_temp.xAxis * -1, client_data_temp.bullet_id)));
        log(LoggingType::DEBUG, "Send Bullet ID: " + std::to_string(client_data_temp.bullet_id));
    }

    client_data_temp.living = (Living) getChar(&data);

    // client the data will be sent to
    if (socket_1 == socket) {
        user_data_1 = client_data_temp;
        user_data_1.m_first_connect = true;
    } else if (socket_2 == socket) {
        user_data_2 = client_data_temp;
        user_data_2.m_first_connect = true;
    } else {
        ////std::cerr << "\t" << "client socket not recognized\n";
        log(LoggingType::ERROR, "Client not recognized: " + socket->peerAddress().toString().toStdString());
    }
    //std::cerr << "\n";
}

void Server::sendEnd3D(QByteArray& data, QTcpSocket* socket){

    data.append(PacketType::end_3D);
    data.append((char*)&winner, 4);

}

/**
 * @brief Server::recvReady_T signalizes if the client has been connected and is ready to start the game it stores the ID
 * of the player
 * @param data array the data will be written to
 * @param socket client where the data came from
 * @param length length of the player_id
 * @param id id of the player
 */
void Server::recvReady_T(char* data, QTcpSocket* socket) {
    //std::cerr << __LINE__ << ", " << __PRETTY_FUNCTION__ << " packet received sucevfully \n";
    int length = getInt(&data);
    char id[length + 1];
    for(int i = 0; i < length; i++)
    {
        id[i] = getChar(&data);
    }
    id[length] = '\0';

    std::string name = std::string(id);

    if (socket_1 == socket) {
        //std::cerr << "\t" << __LINE__ << __FUNCTION__ << "\n";
        user_data_1.name = name;
        user_data_1.m_first_connect = true;
    } else if (socket_2 == socket) {
        //std::cerr << "\t" << __LINE__ << __FUNCTION__ << "\n";
        user_data_2.name = name;
        user_data_2.m_first_connect = true;
    } else {
        ////std::cerr << "\t" << "client socket not recognized\n";
        log(LoggingType::ERROR, "Client not recognized: " + socket->peerAddress().toString().toStdString());
    }
}

/**
 * @brief Server::sendInit_3D sends the package to initalize asteroids and SpaceCraft positions to both clients
 * After every fight the position and asteroids are reset
 * @param response array where the data will be written to
 * @param socket client that recives the data
 */
void Server::sendInit_3D(QByteArray& response, QTcpSocket* socket) {

    // own data like Position,alive flag etc.
    client_data client_data_temp_own;
    //enemy data
    client_data client_data_temp_enemy;

    // depending on player set the data accordingly
    if (socket_1 == socket) {
        client_data_temp_own = user_data_1;
        client_data_temp_enemy = user_data_2;
    } else if (socket_2 == socket) {
        client_data_temp_own = user_data_2;
        client_data_temp_enemy = user_data_1;
    } else {
        ////std::cerr << "\t" << "client socket not recognized\n";
        log(LoggingType::ERROR, "Client not recognized: " + socket->peerAddress().toString().toStdString());
    }

    //write the packet
    response.append(PacketType::init_3D);

    //write own data
    response.append((char*) &client_data_temp_own.position, 12);
    response.append((char*) &client_data_temp_own.xAxis, 12);
    response.append((char*) &client_data_temp_own.yAxis, 12);
    response.append((char*) &client_data_temp_own.zAxis, 12);

    //write enemy data
    response.append((char*) &client_data_temp_enemy.position, 12);
    response.append((char*) &client_data_temp_enemy.xAxis, 12);
    response.append((char*) &client_data_temp_enemy.yAxis, 12);
    response.append((char*) &client_data_temp_enemy.zAxis, 12);

    // create random asteroids, amount is hard coded
    int amount = 10;
    response.append((char*) &amount, 4);

    // add asteroids position,size and direction to package
    for (int i = 0; i < amount; i++) {
        response.append((char*) &i, 4);

        asteroids::Vector3f tmp = pos_astr[i];
        response.append((char*) &tmp, 12);

        tmp = dir_astr[i];
        response.append((char*) &tmp, 12);

        float size = size_astr[i];
        response.append((char*) &size, 4);
    }
    if (socket_1 == socket) {
        response.append(player_no::first);
    } else if (socket_2 == socket) {
        response.append(player_no::second);
    }
}

void Server::resend_init_3d(QTcpSocket* socket){

    //std::cerr << "\t" << __LINE__ << ", " << __PRETTY_FUNCTION__ << "\n";
    ////std::cerr << "\t" << __LINE__ << "\n";
    //sendInit_3D(response, socket);
    m_player1_end_3d_received = false;
    user_data_1.position = {-200, 200, 0};
    user_data_1.xAxis[0] = -1;
    user_data_1.yAxis[1] = -1;
    user_data_1.zAxis[2] = 1;
    user_data_1.shot = Bullet_shot::not_shot;
    user_data_2.position = {100, -0, -0};
    user_data_2.xAxis[0] = 1;
    user_data_2.yAxis[1] = 1;
    user_data_2.zAxis[2] = 1;
    user_data_2.shot = Bullet_shot::not_shot;
    //std::cerr << "\t" << __LINE__ << __FUNCTION__ << "\n";
    if ( (socket == socket_1) && (socket_1->state() == QAbstractSocket::ConnectedState)) {
        QByteArray response;
        sendInit_3D(response, socket_1);
        //std::cerr << "\t" << __LINE__ << __FUNCTION__ << "\n";
        socket_1->write(response); // write the data itself
        socket_1->waitForBytesWritten();
    }  else if ( (socket == socket_2) && (socket_2->state() == QAbstractSocket::ConnectedState)) {
        QByteArray response_2;
        sendInit_3D(response_2, socket_2);
        //std::cerr << "\t" << __LINE__ << __FUNCTION__ << "\n";
        socket_2->write(response_2); // write the data itself
        socket_2->waitForBytesWritten();
    } else {
        log(LoggingType::INFO, "Client not connected on Address: " + socket->peerAddress().toString().toStdString());
    }

}

/**
 * @brief Server::sendGame_Start once the Server has recived the Ready_T package from both player this function is called which
 * tells the player his player id depending on the player_no flag
 * @param response array to manipulate the data
 * @param socket the reciver of the message
 */
void Server::sendGame_Start(QByteArray& response, QTcpSocket* socket) {
    //userdata
    client_data client_data_temp_own;
    client_data client_data_temp_enemy;
    if (socket_1 == socket) {
        client_data_temp_own = user_data_1;
        client_data_temp_enemy = user_data_2;
    } else if (socket_2 == socket) {
        client_data_temp_own = user_data_2;
        client_data_temp_enemy = user_data_1;
    } else {
        ////std::cerr << "\t" << "client socket not recognized\n";
        log(LoggingType::ERROR, "Client not recognized: " + socket->peerAddress().toString().toStdString());
    }
    //package type
    response.append(PacketType::game_start);

    //length of the id
    int length = client_data_temp_enemy.name.length();
    response.append((char*)&length, 4);

    //assign player_no to each player and send the package
    response.append(client_data_temp_enemy.name.c_str(), length);
    if (socket_1 == socket) {
        response.append(player_no::first);
    } else if (socket_2 == socket) {
        response.append(player_no::second);
    }

    //TODO send fist map config data
}


void Server::log(LoggingType type, std::string msg){
    time_t rawtime;
    struct tm * timeinfo;
    char buffer[80];

    time (&rawtime);
    timeinfo = localtime(&rawtime);

    strftime(buffer,sizeof(buffer),"%d-%m-%Y %H:%M:%S",timeinfo);
    std::string str(buffer);

    std::ofstream logfile;
    logfile.open ("log.txt");
    if(type == LoggingType::ERROR){
        std::cerr << "\t" << "[" << str << " ERROR] " << msg << "\n";
        logfile << "[" << str << " ERROR] " << msg << "\n";
    }else if(type == LoggingType::INFO){
        std::cout << "[" << str << " INFO] " << msg << std::endl;
        logfile << "[" << str << " INFO] " << msg << std::endl;
    }else if(type == LoggingType::DEBUG){
        std::cout << "[" << str << " DEBUG] " << msg << std::endl;
        logfile << "[" << str << " DEBUG] " << msg << std::endl;
    }
    logfile.close();
}

/**
 * @brief Server::readyRead recives the Packages sent from each client and interprets the package type. Handles what to do
 * after reciving a package
 */
void Server::readyRead() {
    QTcpSocket* socket = static_cast<QTcpSocket*>(sender());

    //read the data
    QByteArray* buffer = buffers.value(socket);
    qint32* s = sizes.value(socket);
    qint32 size = *s;
    while (socket->bytesAvailable() > 0) {
        buffer->append(socket->readAll());
        while ((size == 0 && buffer->size() >= 4) ||
               (size > 0 && buffer->size() >= size)) // While can process data, process it
        {
            if (size == 0 && buffer->size() >= 4) // if size of data has received completely, then
                                                  // store it on our global variable
            {
                size = ArrayToInt(buffer->mid(0, 4));
                *s = size;
                buffer->remove(0, 4);
            }
            // If data has received completely, then emit
            // our SIGNAL with the data
            if (size > 0 && buffer->size() >= size)

            {
                QByteArray answer = buffer->mid(0, size);
                buffer->remove(0, size);
                size = 0;
                *s = size;

                // Interprete the packet-type:
                char* data = (char*) answer.data();
                PacketType pt = (PacketType) getChar(&data);

                //already send / to be removed TODO
                if(pt == PacketType::planet_changes2d)
                {
                    if(player1_outstanding_fights.empty()){
                    //std::cerr << "\t" << __LINE__ << __FUNCTION__ << "\n";
                        recvPlanetChanges(data, socket);
                    } else {
                    //std::cerr << "\t" << __LINE__ << __FUNCTION__ << "\n";
                        toSend = PacketType::init_3D;
                        this->writeData(nullptr);
                    }
                //} else if (pt == PacketType::update_3D_C && already_send_1 && already_send_2) {
                } else if (pt == PacketType::update_3D_C) {
                    //std::cerr << "\t" << __LINE__ << __FUNCTION__ << "\n";
                    recvUpdate_3D_C(data, socket);
                    toSend = PacketType::update_3D_C;
                    this->writeData(nullptr);
                } else if (pt == PacketType::rerequest_planet_changes) {
                    if(socket_1 == socket)
                    {
                        //std::cerr << "\t" << __LINE__ << __FUNCTION__ << ", socket_1 request_planet_changes\n";
                        pchanges_data1.clear();
                    }
                    if(socket_2 == socket)
                    {
                        //std::cerr << "\t" << __LINE__ << __FUNCTION__ << ", socket_2 request_planet_changes\n";
                        pchanges_data2.clear();
                    }
                    if(player1_outstanding_fights.empty()){
                        //std::cerr << "\t" << __LINE__ << __FUNCTION__ << "\n";
                        resend_UpdatedPlanetChanges(socket);
                    } else {
                        //std::cerr << "\t" << __LINE__ << __FUNCTION__ << "\n";
                        resend_init_3d(socket);
                        //toSend = PacketType::init_3D;
                        //this->writeData(nullptr);
                    }

                } else if (pt == PacketType::end_3D) {
                    recv_end_3D(data, socket);
                    if(player1_outstanding_fights.empty())
                    {
                        //std::cerr << "\t" << __LINE__ << __FUNCTION__ << ", end_3D player1_outstanding_fights.empty()\n";
                        sendUpdatedPlanetChanges();
                    } else {
                        //std::cerr << "\t" << __LINE__ << __FUNCTION__ << ", end_3D, send init_3D, not empty player1_outstanding_fights.empty()\n";
                        toSend = PacketType::init_3D;
                        this->writeData(nullptr);
                    }
                } else if (pt == PacketType::ready_T) {
                    //std::cerr << "\t" << __LINE__ << __FUNCTION__ << "\n";
                    recvReady_T(data, socket);
                    toSend = PacketType::game_start;
                    this->writeData(nullptr);
                } else {
                    toSend=pt;
                    //std::cerr << "\t" << __LINE__ << __FUNCTION__ << ", packet_type: " << pt << " errrrrrrrrrrrrrooooooooor\n";
                    this->writeData(nullptr);
                }


                // direct response after receiving
            }
        }
    }
    //std::cerr << __FUNCTION__ << "end\n";
}

void Server::recv_end_3D(char* data, QTcpSocket* socket){
    //std::cerr << __LINE__ << ", " << __PRETTY_FUNCTION__ << " packet received sucevfully \n";
    player_no winner_loser = (player_no) getChar(&data);
    player_no player_no_temp = (player_no) getChar(&data);
    //std::cerr << "\t" << __LINE__ << __FUNCTION__ << ", player_no" << player_no_temp << ", winner_loser: " << winner_loser << "\n";
    //if(!m_player1_end_3d_received && (player_no::winner == winner_loser)){
    if((player_no::winner == winner_loser) &&  (player1_outstanding_fights.size() > 0)){
        //std::cerr << "\t" << __LINE__ << "\n";
        if(player_no_temp == player_no::first)
        {
        //std::cerr << "\t" << __LINE__ << "\n";
            player1_outstanding_fights.front().m_own = asteroids::PlanetChanges::Owner::PLAYER1;
        //std::cerr << "\t" << __LINE__ << "\n";
            pchanges_committ.push_back(player1_outstanding_fights.front());
        //std::cerr << "\t" << __LINE__ << "\n";
        } else {
        //std::cerr << "\t" << __LINE__ << "\n";
            player2_outstanding_fights.front().m_own = asteroids::PlanetChanges::Owner::PLAYER2;
        //std::cerr << "\t" << __LINE__ << "\n";
            pchanges_committ.push_back(player2_outstanding_fights.front());
        //std::cerr << "\t" << __LINE__ << "\n";
        }
        auto it1 = player1_outstanding_fights.begin();
        player1_outstanding_fights.erase(it1);
        auto it2 = player2_outstanding_fights.begin();
        player2_outstanding_fights.erase(it2);
        m_player1_end_3d_received = true;
        //std::cerr << "\t" << __LINE__ << "\n";
    } else {
        /*
        //std::cerr << "\t" << __LINE__ << "\n";
        if(player_no_temp == player_no::first)
        {
            pchanges_committ.push_back(player2_outstanding_fights.front());
        } else {
            pchanges_committ.push_back(player1_outstanding_fights.front());
        }
        auto it1 = player1_outstanding_fights.begin();
        player1_outstanding_fights.erase(it1);
        auto it2 = player2_outstanding_fights.begin();
        player2_outstanding_fights.erase(it2);
        m_player1_end_3d_received = true;
        */
    }
        //std::cerr << "\t" << __LINE__ << __FUNCTION__ << "\n";
}

void Server::recvPlanetChanges(char* data, QTcpSocket* socket)
{
    //std::cerr << __LINE__ << ", " << __PRETTY_FUNCTION__ << "\n";
    bool this_socket_already_received = false;
    if(socket_1 == socket)
    {
        //std::cerr << "\t" << __LINE__ << __FUNCTION__ << "\n";
        if( m_socket_1_pchange_received) {
            this_socket_already_received = true;
        }
    }
    if(socket_2 == socket)
    {
        //std::cerr << "\t" << __LINE__ << __FUNCTION__ << "\n";
        if( m_socket_2_pchange_received) {
            this_socket_already_received = true;
        }
    }
    if(!this_socket_already_received){
        int size = getInt(&data);
        for(int i = 0 ; i < size ; i++)
        {
            pchanges_data tmp;
            tmp.m_own = (asteroids::PlanetChanges::Owner)getChar(&data);
            tmp.m_id = getInt(&data);
            tmp.m_num_of_ore =getInt(&data) ;
            tmp.num_factory = getInt(&data);
            tmp.num_mine = getInt(&data);
            tmp.num_fighters = getInt(&data);
            tmp.num_transporter = getInt(&data);
            char m_attack_planet  = getChar(&data);
            tmp.stored_ore = getInt(&data);

            //std::cerr << "\t" << __LINE__ << __FUNCTION__ << ", m_own: " << tmp.m_own;
            //std::cerr << ", id " << tmp.m_id;
            //std::cerr << ", ore" << tmp.m_num_of_ore;
            //std::cerr << ", facto" << tmp.num_factory;
            //std::cerr << ", mine" << tmp.num_mine;
            //std::cerr << ", fight" << tmp.num_fighters;
            //std::cerr << ", trans" << tmp.num_transporter;
            //std::cerr << ", attack" << m_attack_planet;
            //std::cerr << ", stored_ore" << tmp.stored_ore << "\n";


            if(m_attack_planet == 1)
            {
                tmp.m_attack_planet = true;
            }else
            {
                tmp.m_attack_planet = false;
            }
            if(socket_1 == socket)
            {
                pchanges_data1.push_back(tmp);
            }
            if(socket_2 == socket)
            {
                pchanges_data2.push_back(tmp);
            }
            //std::cout << pchanges_data1[0].m_own << ","<< pchanges_data1[0].m_id << "," << pchanges_data1[0].m_num_of_ore <<"," << tmp.num_factory <<"," << tmp.num_mine << "," <<tmp.num_fighters << ","   <<tmp.num_transporter << "," <<tmp.m_attack_planet << "\n";
        }
        if(socket_1 == socket)
        {
            //std::cerr << "\t" << __LINE__ << __FUNCTION__ << "\n";
            pchanges_size1 = size;
            m_socket_1_pchange_received = true;
        }
        if(socket_2 == socket)
        {
            //std::cerr << "\t" << __LINE__ << __FUNCTION__ << "\n";
            pchanges_size2 = size;
            m_socket_2_pchange_received = true;
        }
    }
    if((m_socket_1_pchange_received) && (m_socket_2_pchange_received))
    {
        //std::cerr << "\t" << __LINE__ << __FUNCTION__ << "\n";
        //pchanges_size1 = -1;
        //pchanges_size2 = -1;
        pchanges_committ.clear();
        update_planet_changes();
    }
    //std::cerr << "\n";
}

void Server::resend_UpdatedPlanetChanges(QTcpSocket* socket)
{
    //std::cerr << __LINE__ << ", " << __PRETTY_FUNCTION__ << "\n";
    QByteArray data;
    int size = pchanges_committ.size();
    //std::cerr << "\t" << __LINE__ << __FUNCTION__ << ", " <<pchanges_committ.size() << ", size of vector\n";
    data.append(PacketType::planet_changes2d);
    data.append((char*)&size, 4);
    for(unsigned int i= 0 ; i < pchanges_committ.size(); i++)
    {
      pchanges_data tmp = pchanges_committ[i];
      data.append(tmp.m_own);
      data.append((char*)&tmp.m_id, 4);
      data.append((char*)&tmp.m_num_of_ore, 4);
      data.append((char*)&tmp.num_factory, 4);
      data.append((char*)&tmp.num_mine, 4);
      data.append((char*)&tmp.num_fighters, 4);
      data.append((char*)&tmp.num_transporter, 4);
       std::cout << size << "," << tmp.num_transporter <<  "," << tmp.num_mine << "\n";
      if(tmp.m_attack_planet)
      {
          char d = 1;
          data.append(d);
      }
      else
      {
          char d = 0;
          data.append(d);
      }
      //send_changes = true;
      data.append((char*)&tmp.stored_ore, 4);
    }


    //std::cerr << __LINE__ << __FUNCTION__ << "pchanges size: " << pchanges_committ.size() << "\n";
    if( (socket == socket_1) && (socket_1->state() == QAbstractSocket::ConnectedState))
    {
        m_socket_1_pchange_received = false;
        m_socket_2_pchanges_commit_deletable = true;
        //std::cerr << "\t" << __LINE__ << __FUNCTION__ << ", writing something into socket";
        socket_1->write(data); //write the data itself
        socket_1->waitForBytesWritten();
    }else if( (socket == socket_2) && (socket_2->state() == QAbstractSocket::ConnectedState))
    {
        m_socket_2_pchange_received = false;
        //std::cerr << "\t" << __LINE__ << __FUNCTION__ << ", writing something into socket";
        socket_2->write(data); //write the data itself
        socket_2->waitForBytesWritten();
    }
    //pchanges_committ.clear();


    //std::cerr << "\n";
}

void Server::sendUpdatedPlanetChanges()
{
    //std::cerr << __LINE__ << ", " << __PRETTY_FUNCTION__ << "\n";
    QByteArray data;
    int size = pchanges_committ.size();
    //std::cerr << "\t" << __LINE__ << __FUNCTION__ << ", " <<pchanges_committ.size() << ", size of vector\n";
    data.append(PacketType::planet_changes2d);
    data.append((char*)&size, 4);
    for(unsigned int i= 0 ; i < pchanges_committ.size(); i++)
    {
      pchanges_data tmp = pchanges_committ[i];
      data.append(tmp.m_own);
      data.append((char*)&tmp.m_id, 4);
      data.append((char*)&tmp.m_num_of_ore, 4);
      data.append((char*)&tmp.num_factory, 4);
      data.append((char*)&tmp.num_mine, 4);
      data.append((char*)&tmp.num_fighters, 4);
      data.append((char*)&tmp.num_transporter, 4);
       std::cout << size << "," << tmp.num_transporter <<  "," << tmp.num_mine << "\n";
      if(tmp.m_attack_planet)
      {
          char d = 1;
          data.append(d);
      }
      else
      {
          char d = 0;
          data.append(d);
      }
      //send_changes = true;
      data.append((char*)&tmp.stored_ore, 4);
    }


    //std::cerr << __LINE__ << __FUNCTION__ << "pchanges size: " << pchanges_committ.size() << "\n";
    if(socket_1->state() == QAbstractSocket::ConnectedState)
    {
        m_socket_1_pchange_received = false;
        m_socket_2_pchanges_commit_deletable = true;
        //std::cerr << "\t" << __LINE__ << __FUNCTION__ << ", writing something into socket";
        socket_1->write(data); //write the data itself
        socket_1->waitForBytesWritten();
    }
    if(socket_2->state() == QAbstractSocket::ConnectedState)
    {
        m_socket_2_pchange_received = false;
        //std::cerr << "\t" << __LINE__ << __FUNCTION__ << ", writing something into socket";
        socket_2->write(data); //write the data itself
        socket_2->waitForBytesWritten();
    }
    //pchanges_committ.clear();


    //std::cerr << "\n";
}

void Server::update_planet_changes()
{
    //std::cerr << __LINE__ << ", " << __PRETTY_FUNCTION__ << " updating changes\n";
    //std::cerr << "\t" << __LINE__ << __FUNCTION__ << ", pchanges.commit.siz() " << pchanges_committ.size() << "\n";
    // player1 attack
    for(auto it =pchanges_data1.begin() ; it!=pchanges_data1.end();)
    {
        if((*it).m_attack_planet == true)
        {
            //std::cout<< "planet attacking = true\n";
            //std::cerr << "\t" << __LINE__ << __FUNCTION__ << "\n";
            player1_outstanding_fights.push_back((*it));
            int id = it->m_id;
            it = pchanges_data1.erase(it);
            for(auto it2 =pchanges_data2.begin() ; it2!=pchanges_data2.end();)
            {
                if(it2->m_id == id)
                {
                    player2_outstanding_fights.push_back((*it2));
                    it2 = pchanges_data2.erase(it2);
                }  else
                {
                    it2++;
                }

            }
        } else {
            it++;
        }
    }

    //std::cerr << "\t" << __LINE__ << __FUNCTION__ << "\n";
    // player2 attack
    for(auto it = pchanges_data2.begin() ; it!=pchanges_data2.end(); )
    {
        if((*it).m_attack_planet)
        {
            //std::cerr << "\t" << __LINE__ << __FUNCTION__ << "\n";
            player2_outstanding_fights.push_back((*it));
            int id = it->m_id;
            it = pchanges_data2.erase(it);
            for(auto it1 =pchanges_data1.begin() ; it1!=pchanges_data1.end();)
            {
                if(it1->m_id == id)
                {
                    player1_outstanding_fights.push_back(*it1);
                    it1 = pchanges_data1.erase(it1);
                } else
                {
                    it1++;
                }

            }
        } else {
            it++;
        }
    }

    //std::cerr << "\t" << __LINE__ << __FUNCTION__ << ", pchanges_data1.size: " << pchanges_data1.size() << "\n";
    //std::cerr << "\t" << __LINE__ << __FUNCTION__ << ", pchanges_data2.size: " << pchanges_data2.size() << "\n";

    // player2 and player1 want same planet
    for(auto it2 = pchanges_data2.begin() ; it2!=pchanges_data2.end(); )
    {
        //std::cerr << "\t" << __LINE__ << "\n";
        bool increment = true;
        for(auto it1 =pchanges_data1.begin() ; it1!=pchanges_data1.end();)
        {
            if(it2->m_id == it1->m_id)
            {
                //std::cerr << "\t" << __LINE__ << " \n";
                player1_outstanding_fights.push_back((*it1));
                it1 = pchanges_data1.erase(it1);
                player2_outstanding_fights.push_back((*it2));
                it2 = pchanges_data2.erase(it2);
                increment = false;
                break;
            } else {
                //std::cerr << "\t" << __LINE__ << " \n";
                it1++;
            }
        }
        if(increment)
        {
            it2++;
        }
    }

    //std::cerr << "\t" << __LINE__ << __FUNCTION__ << ", pchanges_data1.size: " << pchanges_data1.size() << "\n";
    //std::cerr << "\t" << __LINE__ << __FUNCTION__ << ", pchanges_data2.size: " << pchanges_data2.size() << "\n";

    for(auto it = pchanges_data1.begin(); it != pchanges_data1.end() ; it++)
    {
        //std::cerr << "\t" << __LINE__ << "\n";

        pchanges_committ.push_back((*it));
    }

    for(auto it = pchanges_data2.begin(); it != pchanges_data2.end() ; it++)
    {
        //std::cerr << "\t" << __LINE__<< __FUNCTION__ << "\n";

        pchanges_committ.push_back((*it));
    }
    pchanges_data2.clear();
    pchanges_data1.clear();
    if(player1_outstanding_fights.empty())
    {
        //std::cerr << "\t" << __LINE__ << __FUNCTION__ << "\n";
        sendUpdatedPlanetChanges();
    }
    else
    {
        //std::cerr << "\t" << __LINE__ << __FUNCTION__ << ", ";
        //std::cerr << "\t" << "player1_outstanding_fights, " << player1_outstanding_fights.size() << ", ";
        //std::cerr << "\t" << "player2_outstanding_fights, " << player2_outstanding_fights.size() << "\n";
        toSend = PacketType::init_3D;
        this->writeData(nullptr);
    }
    //std::cerr << "\t" << __LINE__ << __FUNCTION__ << ", pchanges.commit.size() " << pchanges_committ.size() << "\n";
    //std::cerr << "\n";
}

// maniuplate the QByteArray for depending values of package we are reciving
float Server::getFloat(char** ptr) {
    float* jo = (float*) *ptr;
    float f = *jo;
    *ptr += 4;
    return f;
}

/**
 * @brief Server::getShort manipulates the pointer by incrementing and returning short value
 * @param ptr pointer that will be manipulated
 * @return short Value at position of pointer
 */
short Server::getShort(char** ptr) {
    short* jo = (short*) *ptr;
    short f = *jo;
    *ptr += 2;
    return f;
}

/**
 * @brief Server::getChar manipulates the pointer by incrementing and returning short value
 * @param ptr pointer that will be manipulated
 * @return char value at position
 */
char Server::getChar(char** ptr) {
    char f = **ptr;
    *ptr += 1;
    return f;
}

/**
 * @brief Server::getInt manipulates the pointer by incrementing and returning short value
 * @param ptr pointer that will be manipulated
 * @return int Value at position
 */
int Server::getInt(char** ptr) {
    int* jo = (int*) *ptr;
    int f = *jo;
    *ptr += 4;
    return f;
}

/**
 * @brief ArrayToInt serializes the array in qt-Way
 * @param source data to ber serialized
 */
qint32 ArrayToInt(QByteArray source) {
    qint32 temp;
    QDataStream data(&source, QIODevice::ReadWrite);
    data >> temp;
    return temp;
}

/**
 * @brief IntToArray deserializes source
 */
QByteArray IntToArray(qint32 source) // Use qint32 to ensure that the number have 4 bytes
{

    QByteArray temp;
    QDataStream data(&temp, QIODevice::ReadWrite);
    data << source;
    return temp;
}
